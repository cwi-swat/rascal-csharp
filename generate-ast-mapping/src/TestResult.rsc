module TestResult
public alias CSharpFile=list[AstNode];
data AstNode = comment(Comment commentType, str content, bool startsLine)
  |  namespaceDeclaration(str name, str fullName, list[AstNode] identifiers, list[AstNode] members)
  |  constraint(list[AstType] baseTypes, str typeParameter)
  |  attribute(list[Expression] arguments)
  |  queryOrdering(QueryOrderingDirection direction, Expression expression)
  |  cSharpModifierToken(list[Modifiers] allModifiers, list[Modifiers] modifier)
  |  variablePlaceholder(str name, Expression initializer)
  |  usingDeclaration(str namespace)
  |  cSharpTokenNode()
  |  parameterDeclaration(str name, list[AstNode] attributes, Expression defaultExpression, ParameterModifier parameterModifier)
  |  switchSection(list[AstNode] caseLabels, list[Statement] statements)
  |  usingAliasDeclaration(str \alias)
  |  typeParameterDeclaration(str name, VarianceModifier variance)
  |  catchClause(Statement body, str variableName)
  |  identifier(str name)
  |  attributeSection(AttributeTarget attributeTarget, list[AstNode] attributesA)
  |  constructorInitializer(list[Expression] arguments, ConstructorInitializer constructorInitializerType)
  |  compilationUnit()
  |  variableInitializer(str name, Expression initializer)
  |  arraySpecifier(int dimensions)
  |  caseLabel(Expression expression)
  |  statement(Statement nodeStatement)
  |  astType(AstType nodeAstType)
  |  attributedNode(AttributedNode nodeAttributedNode)
  |  expression(Expression nodeExpression)
  |  queryClause(QueryClause nodeQueryClause);

data QueryClause = queryContinuationClause(str identifier, Expression precedingQuery)
  |  queryWhereClause(Expression condition)
  |  queryGroupClause(Expression key, Expression projection)
  |  queryOrderClause(list[AstNode] orderings)
  |  querySelectClause(Expression expression)
  |  queryLetClause(Expression expression, str identifier)
  |  queryFromClause(Expression expression, str identifier)
  |  queryJoinClause(Expression equalsExpression, Expression inExpression, str intoIdentifier, bool isGroupJoin, str joinIdentifier, Expression onExpression);

data Expression = lambdaExpression(AstNode body, list[AstNode] parameters)
  |  conditionalExpression(Expression condition, Expression falseExpression, Expression trueExpression)
  |  binaryOperatorExpression(Expression left, BinaryOperator operator, Expression right)
  |  directionExpression(Expression expression, FieldDirection fieldDirection)
  |  castExpression(Expression expression)
  |  indexerExpression(list[Expression] arguments, Expression target)
  |  parenthesizedExpression(Expression expression)
  |  baseReferenceExpression()
  |  sizeOfExpression()
  |  arrayCreateExpression(list[AstNode] additionalArraySpecifiers, list[Expression] arguments, Expression initializer)
  |  unaryOperatorExpression(Expression expression, UnaryOperator operatorU)
  |  asExpression(Expression expression)
  |  typeReferenceExpression()
  |  typeOfExpression()
  |  defaultValueExpression()
  |  anonymousMethodExpression(Statement bodyS, bool hasParameterList, list[AstNode] parameters)
  |  uncheckedExpression(Expression expression)
  |  isExpression(Expression expression)
  |  identifierExpression(str identifier, list[AstType] typeArguments)
  |  checkedExpression(Expression expression)
  |  primitiveExpression(value \value)
  |  expressionPlaceholder()
  |  objectCreateExpression(list[Expression] arguments, Expression initializer)
  |  namedArgumentExpression(Expression expression, str identifier)
  |  argListExpression(list[Expression] arguments, bool isAccess)
  |  memberReferenceExpression(str memberName, Expression target, list[AstType] typeArguments)
  |  invocationExpression(list[Expression] arguments, Expression target)
  |  pointerReferenceExpression(str memberName, Expression target, list[AstType] typeArguments)
  |  assignmentExpression(Expression left, AssignmentOperator operatorA, Expression right)
  |  thisReferenceExpression()
  |  stackAllocExpression(Expression countExpression)
  |  arrayInitializerExpression(list[Expression] elements)
  |  queryExpression(list[QueryClause] clauses);

data AttributedNode = enumMemberDeclaration(str name, list[AstNode] attributes, Expression initializer, list[AstNode] modifierTokens, list[Modifiers] modifiers)
  |  accessor(list[AstNode] attributes, Statement body, list[AstNode] modifierTokens, list[Modifiers] modifiers)
  |  delegateDeclaration(str name, list[AstNode] attributes, list[AstNode] constraints, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] parameters, list[AstNode] typeParameters)
  |  destructorDeclaration(str name, list[AstNode] attributes, Statement body, list[AstNode] modifierTokens, list[Modifiers] modifiers)
  |  typeDeclaration(str name, list[AstNode] attributes, list[AstType] baseTypes, Class classType, list[AstNode] constraints, list[AttributedNode] members, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] typeParameters)
  |  constructorDeclaration(str name, list[AstNode] attributes, Statement body, AstNode initializerA, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] parameters)
  |  memberDeclaration(MemberDeclaration nodeMemberDeclaration);

data MemberDeclaration = indexerDeclaration(str name, list[AstNode] attributes, AttributedNode getter, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] parameters, AttributedNode setter)
  |  methodDeclaration(str name, list[AstNode] attributes, Statement body, list[AstNode] constraints, bool isExtensionMethod, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] parameters, list[AstNode] typeParameters)
  |  operatorDeclaration(str name, list[AstNode] attributes, Statement body, list[AstNode] modifierTokens, list[Modifiers] modifiers, Operator operatorType, list[AstNode] parameters)
  |  propertyDeclaration(str name, list[AstNode] attributes, AttributedNode getter, list[AstNode] modifierTokens, list[Modifiers] modifiers, AttributedNode setter)
  |  customEventDeclaration(str name, AttributedNode addAccessor, list[AstNode] attributes, list[AstNode] modifierTokens, list[Modifiers] modifiers, AttributedNode removeAccessor)
  |  fieldDeclaration(str name, list[AstNode] attributes, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] variables)
  |  eventDeclaration(str name, list[AstNode] attributes, list[AstNode] modifierTokens, list[Modifiers] modifiers, list[AstNode] variables);

data AstType = simpleType(str identifier, list[AstType] typeArguments)
  |  composedType(list[AstNode] arraySpecifiers, bool hasNullableSpecifier, int pointerRank)
  |  typePlaceholder()
  |  memberType(bool isDoubleColon, str memberName, list[AstType] typeArguments)
  |  primitiveType(str keyword);

data Statement = returnStatement(Expression expression)
  |  whileStatement(Expression condition, Statement embeddedStatement)
  |  yieldBreakStatement()
  |  blockStatementPlaceholder(list[Statement] statements)
  |  gotoCaseStatement(Expression labelExpression)
  |  fixedStatement(Statement embeddedStatement, list[AstNode] variables)
  |  labelStatement(str label)
  |  switchStatement(Expression expression, list[AstNode] switchSections)
  |  ifElseStatement(Expression condition, Statement falseStatement, Statement trueStatement)
  |  expressionStatement(Expression expression)
  |  gotoDefaultStatement()
  |  variableDeclarationStatement(list[Modifiers] modifiers, list[AstNode] variables)
  |  breakStatement()
  |  tryCatchStatement(list[AstNode] catchClauses, Statement finallyBlock, Statement tryBlock)
  |  gotoStatement(str label)
  |  usingStatement(Statement embeddedStatement, AstNode resourceAcquisition)
  |  throwStatement(Expression expression)
  |  unsafeStatement(Statement body)
  |  doWhileStatement(Expression condition, Statement embeddedStatement)
  |  continueStatement()
  |  checkedStatement(Statement body)
  |  statementPlaceholder()
  |  forStatement(Expression condition, Statement embeddedStatement, list[Statement] initializers, list[Statement] iterators)
  |  foreachStatement(Statement embeddedStatement, Expression inExpression, str variableName)
  |  lockStatement(Statement embeddedStatement, Expression expression)
  |  blockStatement(list[Statement] statements)
  |  emptyStatement()
  |  yieldStatement(Expression expression)
  |  uncheckedStatement(Statement body);

data ConstructorInitializer = this()
  |  base();

data ParameterModifier = parameterModifierThis()
  |  parameterModifierNone()
  |  parameterModifierParams()
  |  parameterModifierRef()
  |  parameterModifierOut();

data QueryOrderingDirection = queryOrderingDirectionAscending()
  |  queryOrderingDirectionNone()
  |  queryOrderingDirectionDescending();

data UnaryOperator = bitNot()
  |  dereference()
  |  not()
  |  plus()
  |  decrement()
  |  minus()
  |  postIncrement()
  |  postDecrement()
  |  addressOf()
  |  increment();

data FieldDirection = fieldDirectionNone()
  |  fieldDirectionRef()
  |  fieldDirectionOut();

data BinaryOperator = conditionalOr()
  |  divide()
  |  inEquality()
  |  conditionalAnd()
  |  bitwiseOr()
  |  bitwiseAnd()
  |  modulus()
  |  equality()
  |  lessThanOrEqual()
  |  lessThan()
  |  shiftLeft()
  |  greaterThan()
  |  add()
  |  exclusiveOr()
  |  shiftRight()
  |  multiply()
  |  \any()
  |  nullCoalescing()
  |  greaterThanOrEqual()
  |  subtract();

data AssignmentOperator = assignmentOperatorShiftLeft()
  |  assignmentOperatorDivide()
  |  assignmentOperatorAssign()
  |  assignmentOperatorBitwiseOr()
  |  assignmentOperatorAdd()
  |  assignmentOperatorExclusiveOr()
  |  assignmentOperatorShiftRight()
  |  assignmentOperatorMultiply()
  |  assignmentOperatorAny()
  |  assignmentOperatorBitwiseAnd()
  |  assignmentOperatorModulus()
  |  assignmentOperatorSubtract();

data Class = delegate()
  |  interface()
  |  \module()
  |  class()
  |  enum()
  |  struct();

data Modifiers = modifiersReadonly()
  |  modifiersVirtual()
  |  modifiersPartial()
  |  modifiersNew()
  |  modifiersConst()
  |  modifiersProtected()
  |  modifiersPublic()
  |  modifiersSealed()
  |  modifiersAbstract()
  |  modifiersExtern()
  |  modifiersNone()
  |  modifiersStatic()
  |  modifiersVisibilityMask()
  |  modifiersOverride()
  |  modifiersInternal()
  |  modifiersUnsafe()
  |  modifiersFixed()
  |  modifiersVolatile()
  |  modifiersPrivate();

data Comment = multiLine()
  |  singleLine()
  |  documentation();

data Operator = operatorImplicit()
  |  operatorTrue()
  |  operatorBitwiseOr()
  |  operatorDivision()
  |  operatorDecrement()
  |  operatorUnaryNegation()
  |  operatorLeftShift()
  |  operatorBitwiseAnd()
  |  operatorSubtraction()
  |  operatorRightShift()
  |  operatorModulus()
  |  operatorIncrement()
  |  operatorEquality()
  |  operatorInequality()
  |  operatorLessThanOrEqual()
  |  operatorLessThan()
  |  operatorLogicalNot()
  |  operatorGreaterThan()
  |  operatorUnaryPlus()
  |  operatorExclusiveOr()
  |  operatorExplicit()
  |  operatorMultiply()
  |  operatorFalse()
  |  operatorAddition()
  |  operatorGreaterThanOrEqual()
  |  operatorOnesComplement();

data AttributeTarget = attributeTargetField()
  |  attributeTargetNone()
  |  attributeTargetReturn()
  |  attributeTargetUnknown()
  |  attributeTargetType()
  |  attributeTargetModule()
  |  attributeTargetAssembly()
  |  attributeTargetMethod()
  |  attributeTargetParam();

data VarianceModifier = invariant()
  |  covariant()
  |  contravariant();
